# Bloom Filter

üåç *[Portugu√™s](README_pt.md)*

A **Bloom Filter** is a probabilistic data structure used to represent a set of elements as a bit vector. The primary function of a Bloom Filter is to determine whether an element belongs to a set, allowing for **false positives** (claiming an element is in the set when it actually is not) but never **false negatives** (claiming an element is not in the set when it actually is).

The basic operations that a Bloom Filter supports:

- **Insertion**: When an item is added, several hash functions are used to calculate multiple indices in the bit vector. The bits at these indices are set to 1.
- **Query**: When querying for the presence of an item, the hash functions calculate the same indices. If **all bits corresponding to these indices are marked as 1**, the Bloom Filter returns that the item **might** be present. Otherwise, it returns that the item is **not** in the set.

## Mathematical Description of a Bloom Filter

We can define the behavior of a Bloom Filter as a function that maps a set of elements to a bit vector and the operation of verifying an element against this set.

### Defining the Bloom Filter

Given:

- A set of elements $S \subseteq \Sigma^*$, where $\Sigma^*$ is the set of all possible strings.
- A **bit vector** $B \in \lbrace 0, 1\rbrace^m$ of size $m$, where $m$ is the number of bits available in the Bloom Filter.
- $k$ distinct hash functions $h_1, h_2, ..., h_k$, where each $h_i: \Sigma^* \rightarrow \lbrace 0, 1, \dots, m-1\rbrace$ maps an element from $\Sigma^*$ to an index between 0 and $m-1$.

#### Insertion Function:

The insertion function of the Bloom Filter, denoted by $\phi_{\text{add}}: \lbrace 0,1\rbrace^m\times\Sigma^* \rightarrow \lbrace 0, 1\rbrace^m$, updates the bit vector $B$ when an element $x \in \Sigma^*$ is added. Each hash function $h_i(x)$ generates an index in vector $B$, and the corresponding bit is marked as 1. Denoting $B[i]$ as the $i$-th coordinate of $B$, the insertion function is defined as:

$$
\phi_{\text{add}}(B_0,x) = B_1 
$$

where

$$
B_1[i] = \begin{cases}
1 &\text{ if }i\in\lbrace h_1(x), \dots, h_k(x)\rbrace,\\
B_0[i] &\text{ otherwise.}
\end{cases}
$$

#### Query Function:

The query function $\phi_{\text{query}}: \lbrace 0,1\rbrace^m \times \Sigma^* \rightarrow \lbrace 0, 1\rbrace$ verifies whether an element $x \in \Sigma^*$ might be in the set $B$ represented by the Bloom Filter. To do so, it checks the bits corresponding to indices $h_1(x), h_2(x), \dots, h_k(x)$. If any of these bits is 0, the element is definitely **not** in the set. If all bits are 1, the element **might** be in the set (with a possibility of false positives).

The query function is defined as:

$$
\phi_{\text{query}}(x) = 
\begin{cases} 
1 & \text{ if } B[h_i(x)] = 1 \text{, }\forall i = 1, 2, \dots, k, \\ 
0 & \text{ otherwise.}
\end{cases}
$$

In other words, $x$ **might** be in the set if all bits $B[h_1(x)], B[h_2(x)], \dots, B[h_k(x)]$ are equal to 1, and is **definitely not** in the set if any of these bits is 0.

## False Positive Probability in a Bloom Filter

The **false positive probability** is one of the main characteristics of a **Bloom Filter** and is critical to understanding the probabilistic behavior of the structure. In a Bloom Filter, a **false positive** occurs when the filter returns **true** (i.e., claims that an item is in the set) for an item that **has not** actually been inserted into the filter.

Remember that the Bloom Filter never returns a false negative. In other words, if an item was inserted into the filter, the query will always correctly indicate that it is in the set. What may happen is that the filter, based on the combination of hash functions, might erroneously indicate that an **unincluded** item is present in the set.

### Calculating the False Positive Probability

The probability of false positives in a Bloom Filter depends on three main factors:

- **$n$**: The number of elements inserted into the filter.
- **$m$**: The number of bits in the vector.
- **$k$**: The number of hash functions used.

When an item is inserted into the Bloom Filter, the bits corresponding to the indices generated by the hash functions are set to 1. As more elements are inserted, the probability of a bit being 1 increases. The **false positive probability** depends on the number of bits set to 1 and the chance of an uninserted item matching the same indices.

### Probability of a Bit Being 1

To calculate the false positive probability, we first need to understand the probability of a specific bit being 1 after inserting $n$ elements. This depends on the number of hash functions $k$ and the number of bits $m$.

Each inserted element affects $k$ bits (one for each hash function), so after inserting $n$ elements, the total number of bit markings is $kn$. However, a specific bit is not necessarily marked, as the hash function distributes values uniformly. The probability of a bit not being marked by a single inserted element is:

$$
P(\text{bit not marked by one element}) = 1 - \frac{1}{m}
$$

After inserting $n$ elements, the probability of a bit not being marked by **any** of these $n$ elements is:

$$
P(\text{bit not marked after n elements}) = \left( 1 - \frac{1}{m} \right)^{kn}
$$

Therefore, the probability of a bit being **marked** after $n$ insertions is:

$$
P(\text{bit marked}) = 1 - \left( 1 - \frac{1}{m} \right)^{kn}
$$

### False Positive Probability

Now, we calculate the probability of a false positive for an **uninserted item**.

For an item not inserted into the Bloom Filter, it will be considered present in the set if all $k$ bits corresponding to it are 1. Since bits are independently marked, the probability of a **specific bit** being marked as 1 (when the item was not inserted) is $P(\text{bit marked})$.

Thus, the probability of **all $k$ bits** corresponding to an uninserted item being marked as 1 is:

$$
P_{\text{false positive}} = \left( P(\text{bit marked}) \right)^k
$$

Substituting the value of $P(\text{bit marked})$:

$$
P_{\text{false positive}} = \left( 1 - \left( 1 - \frac{1}{m} \right)^{kn} \right)^k
$$

### Approximation of False Positive Probability

For large values of $n$ (number of inserted elements) and $m$ (size of the bit vector), we can simplify the expression for false positive probability. Using the approximation $\left(1 - \frac{1}{m}\right)^{kn} \approx e^{-\frac{kn}{m}}$, we get:

$$
P_{\text{false positive}} \approx \left( 1 - e^{-\frac{kn}{m}} \right)^k
$$

### Optimization of the Number of Hash Functions

To minimize the false positive rate, it is important to choose the appropriate number of hash functions $k$. The optimal $k$ that minimizes the false positive probability can be calculated by differentiating the expression for $P_{\text{false positive}}$ and solving for $k$. The result is:

$$
k^* = \frac{m}{n} \ln(2)
$$

Where:

- $k^*$ is the optimal number of hash functions.
- $m$ is the size of the bit vector.
- $n$ is the number of elements inserted into the filter.

### Final Formula for False Positive Probability

Combining all the above, the **false positive probability** in a Bloom Filter is approximately given by:

$$
P_{\text{false positive}} \approx \left( 1 - e^{-\frac{kn}{m}} \right)^k
$$

---

### Efficient Implementation of a Bloom Filter Using MurmurHash3

This implementation of a Bloom Filter uses the **MurmurHash3** function with a seed to generate multiple hash functions, ensuring high performance and good hash dispersion.

#### **Key Features**
1. **MurmurHash3**: A fast, non-cryptographic hash function designed for high performance and low collision rates.
2. **Efficient Bit Manipulation**: Uses a compact bitset implemented as an array of `uint64` values for memory efficiency.
3. **Single Hash Function with Seed**: Leverages the same hash function with varying seeds to simulate multiple hash functions, improving simplicity and performance.

#### **Code Overview**

The core functionality is divided into the following components:

1. **Initialization**:
   - The `NewBloomFilter` function initializes the bitset and configures the Bloom Filter with the desired size and number of hash functions.

2. **MurmurHash3 with Seed**:
   - The `murmurHash3` function computes a 64-bit hash value based on the input data and a seed value. Each seed produces a distinct hash function.

3. **Add Operation**:
   - The `Add` method computes multiple hash values for the given item and sets the corresponding bits in the bitset.

4. **Contains Operation**:
   - The `Contains` method checks if all the bits corresponding to the item's hash values are set. If any bit is not set, the item is definitely not in the set.

#### **How to Use**

Here‚Äôs how you can use this Bloom Filter implementation in your Go application:

1. **Import the Package**:
   - Ensure your file imports the necessary packages (`encoding/binary`).

2. **Create a Bloom Filter**:
   ```go
   bf := NewBloomFilter(1000, 3)
   ```
   - `1000`: The size of the bitset.
   - `3`: The number of hash functions.

3. **Add Items to the Filter**:
   ```go
   bf.Add("example1")
   bf.Add("example2")
   ```

4. **Check for Item Membership**:
   ```go
   println(bf.Contains("example1")) // Outputs: true
   println(bf.Contains("example3")) // Outputs: false (or true if a false positive occurs)
   ```

#### **Example Program**
```go
package main

func main() {
    // Create a Bloom Filter with a size of 1000 bits and 3 hash functions
    bf := NewBloomFilter(1000, 3)

    // Add elements to the Bloom Filter
    bf.Add("example1")
    bf.Add("example2")

    // Check for membership
    println(bf.Contains("example1")) // true
    println(bf.Contains("example2")) // true
    println(bf.Contains("example3")) // false (possible false positive)
}
```

#### **Performance Considerations**
1. **Space Efficiency**: The bitset is implemented as an array of `uint64` for reduced memory usage.
2. **Hash Function Quality**: MurmurHash3 provides excellent dispersion and speed, ensuring low collision rates.
3. **Trade-Offs**:
   - False positives increase as more items are added, but the probability can be reduced by adjusting the size of the bitset and the number of hash functions.

This implementation strikes a balance between simplicity, performance, and accuracy, making it a great choice for applications requiring fast and memory-efficient membership checks.

---

### Final Considerations

- **False Positive Rate**: The Bloom Filter offers excellent space efficiency but allows for false positives. The probability of false positives can be controlled by adjusting the number of hash functions $k$ and the size of the bit vector $m$.
- **Capacity Impact**: As more elements are inserted into the filter ($n$), the probability of hash collisions increases, raising the chance of false positives.

See also [Bloom Filter Calculator](https://hur.st/bloomfilter/?n=30&p=1.0E-7&m=&k=6)
